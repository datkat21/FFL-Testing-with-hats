// this file maps FFL enums to strings for displaying errors, etc.

#include <nn/ffl.h>

#include <filedevice/rio_FileDevice.h>
#include <unordered_map>

const char* FFLiVerifyCharInfoReasonStrings[] = {
    "FFLI_VERIFY_CHAR_INFO_REASON_OK",
    "FFLI_VERIFY_CHAR_INFO_REASON_FACELINE_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_FACELINE_COLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_FACELINE_TEXTURE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_FACELINE_MAKE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_HAIR_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_HAIR_COLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_HAIR_FLIP_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYE_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYE_COLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYE_SCALE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYE_ASPECT_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYE_ROTATE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYE_X_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYE_Y_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYEBROW_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYEBROW_COLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYEBROW_SCALE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYEBROW_ASPECT_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYEBROW_ROTATE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYEBROW_X_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_EYEBROW_Y_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_NOSE_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_NOSE_SCALE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_NOSE_Y_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOUTH_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOUTH_COLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOUTH_SCALE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOUTH_ASPECT_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOUTH_Y_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_BEARD_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_BEARD_COLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MUSTACHE_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MUSTACHE_SCALE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MUSTACHE_Y_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_GLASS_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_GLASS_COLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_GLASS_SCALE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_GLASS_Y_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOLE_TYPE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOLE_SCALE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOLE_X_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_MOLE_Y_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_HEIGHT_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_BUILD_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_NAME_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_CREATORNAME_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_GENDER_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_BIRTHDAY_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_FAVORITECOLOR_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_REGIONMOVE_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_FONTREGION_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_ROOM_INDEX_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_POSITION_IN_ROOM_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_BIRTH_PLATFORM_INVALID",
    "FFLI_VERIFY_CHAR_INFO_REASON_CREATEID_INVALID"
};

/* NOTE: the following is the real enum:
typedef enum FFLResult
{
    FFL_RESULT_SUCCESS                   =  0,
    FFL_RESULT_WRONG_PARAM               =  1,
    FFL_RESULT_DB_NO_DATA                =  2,
    FFL_RESULT_BROKEN                    =  3,
    FFL_RESULT_NOT_AVAILABLE             =  4,
    FFL_RESULT_FATAL                     =  5,
    FFL_RESULT_LOAD_FAIL                 =  6,
    FFL_RESULT_SAVE_FAIL                 =  7,
    FFL_RESULT_BUSY                      =  8,
    FFL_RESULT_NAND_COMMAND_FAIL         =  9,
    FFL_RESULT_FORMATTED                 = 10,
    FFL_RESULT_DB_FULL                   = 11,
    FFL_RESULT_TEMP_MEMORY_SHORT         = 12,
    FFL_RESULT_INTERNAL0                 = 13,
    FFL_RESULT_INTERNAL1                 = 14,
    FFL_RESULT_INTERNAL2                 = 15,
    FFL_RESULT_FAILED_SYSTEM0            = 16,
    FFL_RESULT_FAILED_ACT                = 17,
    FFL_RESULT_FAILED_FS                 = 18,
    FFL_RESULT_RUN_MII_STUDIO            = 19
}
FFLResult;
*/
const char* FFLResultStrings[] = {
    "FFL_RESULT_OK",
    "FFL_RESULT_ERROR",
    "FFL_RESULT_HDB_EMPTY",
    "FFL_RESULT_FILE_INVALID",
    "FFL_RESULT_MANAGER_NOT_CONSTRUCT",
    "FFL_RESULT_FILE_LOAD_ERROR",
    "FFL_RESULT_UNKNOWN_6",
    "FFL_RESULT_FILE_SAVE_ERROR",
    "FFL_RESULT_UNKNOWN_8",
    "FFL_RESULT_RES_FS_ERROR",
    "FFL_RESULT_ODB_EMPTY",
    "FFL_RESULT_UNKNOWN_11",
    "FFL_RESULT_OUT_OF_MEMORY",
    "FFL_RESULT_UNKNOWN_13",
    "FFL_RESULT_UNKNOWN_14",
    "FFL_RESULT_UNKNOWN_15",
    "FFL_RESULT_UNKNOWN_16",
    "FFL_RESULT_UNKNOWN_17",
    "FFL_RESULT_FS_ERROR",
    "FFL_RESULT_FS_NOT_FOUND"
};

const char* FFLResourceTypeStrings[] = {
    "FFL_RESOURCE_TYPE_MIDDLE",
    "FFL_RESOURCE_TYPE_HIGH",
    "FFL_RESOURCE_TYPE_VERY_HIGH",
    "FFL_RESOURCE_TYPE_LOW"
};



#include <stdio.h>

#define UNKNOWN "(unknown)"

const char* FFLiVerifyCharInfoReasonToString(FFLiVerifyCharInfoReason reason)
{
    // make sure it is in range
    if (reason < 0 || reason > FFLI_VERIFY_CHAR_INFO_REASON_CREATEID_INVALID)
        return UNKNOWN;

    return FFLiVerifyCharInfoReasonStrings[reason];
}

const char* FFLResultToString(FFLResult result)
{
    // make sure it is in range
    if (result < 0 || result > FFL_RESULT_FS_NOT_FOUND)
        return UNKNOWN;

    return FFLResultStrings[result];
}

const char* FFLResourceTypeToString(s32 type)
{
    // make sure it is in range
    if (type < 0 || type > 4)
        return UNKNOWN;

    return FFLResourceTypeStrings[type];
}

// map for rio::RawErrorCode, for file acccess failures
const std::unordered_map<int, const char*> rioRawErrorCodeStrings = {
    {rio::RAW_ERROR_OK, "rio::RAW_ERROR_OK"},
    {rio::RAW_ERROR_CANCELED, "rio::RAW_ERROR_CANCELED"},
    {rio::RAW_ERROR_END, "rio::RAW_ERROR_END"},
    {rio::RAW_ERROR_ALREADY_OPEN, "rio::RAW_ERROR_ALREADY_OPEN"},
    {rio::RAW_ERROR_NOT_FOUND, "rio::RAW_ERROR_NOT_FOUND"},
    {rio::RAW_ERROR_NOT_FILE, "rio::RAW_ERROR_NOT_FILE"},
    {rio::RAW_ERROR_ACCESS_ERROR, "rio::RAW_ERROR_ACCESS_ERROR"},
    {rio::RAW_ERROR_PERMISSION_ERROR, "rio::RAW_ERROR_PERMISSION_ERROR"},
    {rio::RAW_ERROR_FILE_TOO_BIG, "rio::RAW_ERROR_FILE_TOO_BIG"},
    {rio::RAW_ERROR_STORAGE_FULL, "rio::RAW_ERROR_STORAGE_FULL"},
    {rio::RAW_ERROR_FATAL_ERROR, "rio::RAW_ERROR_FATAL_ERROR"}
};

static const char* rioRawErrorCodeToString(rio::RawErrorCode code)
{
    const auto it = rioRawErrorCodeStrings.find(code);
    if (it != rioRawErrorCodeStrings.end()) {
        return it->second;
    } else {
        return UNKNOWN;
    }
}
